//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace KeyController
{
    using Microsoft.AspNetCore.Mvc;
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IController
    {

        /// <summary>
        /// Creates a new key, stores it, then returns key parameters and attributes to the client.
        /// </summary>

        /// <remarks>
        /// The create key operation can be used to create any key type in Azure Key Vault. If the named key already exists, Azure Key Vault creates a new version of the key. It requires the keys/create permission.
        /// </remarks>

        /// <param name="key_name">The name for the new key. The system will generate the version name for the new key. The value you provide may be copied globally for the purpose of running the service. The value provided should not include personally identifiable or sensitive information.</param>

        /// <param name="parameters">The parameters to create a key.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>A key bundle containing the result of the create key request.</returns>

        System.Threading.Tasks.Task<KeyBundle> CreateKeyAsync(string key_name, KeyCreateParameters parameters, string api_version);

        /// <summary>
        /// Creates a new key version, stores it, then returns key parameters, attributes and policy to the client.
        /// </summary>

        /// <remarks>
        /// The operation will rotate the key based on the key policy. It requires the keys/rotate permission.
        /// </remarks>

        /// <param name="key_name">The name of key to be rotated. The system will generate a new version in the specified key.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>A key bundle containing the result of the rotate key request.</returns>

        System.Threading.Tasks.Task<KeyBundle> RotateKeyAsync(string key_name, string api_version);

        /// <summary>
        /// Imports an externally created key, stores it, and returns key parameters and attributes to the client.
        /// </summary>

        /// <remarks>
        /// The import key operation may be used to import any key type into an Azure Key Vault. If the named key already exists, Azure Key Vault creates a new version of the key. This operation requires the keys/import permission.
        /// </remarks>

        /// <param name="key_name">Name for the imported key. The value you provide may be copied globally for the purpose of running the service. The value provided should not include personally identifiable or sensitive information.</param>

        /// <param name="parameters">The parameters to import a key.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>Imported key bundle to the vault.</returns>

        System.Threading.Tasks.Task<KeyBundle> ImportKeyAsync(string key_name, KeyImportParameters parameters, string api_version);

        /// <summary>
        /// Deletes a key of any type from storage in Azure Key Vault.
        /// </summary>

        /// <remarks>
        /// The delete key operation cannot be used to remove individual versions of a key. This operation removes the cryptographic material associated with the key, which means the key is not usable for Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations. This operation requires the keys/delete permission.
        /// </remarks>

        /// <param name="key_name">The name of the key to delete.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The public part of the deleted key and deletion information on when the key will be purged.</returns>

        System.Threading.Tasks.Task<DeletedKeyBundle> DeleteKeyAsync(string key_name, string api_version);

        /// <summary>
        /// The update key operation changes specified attributes of a stored key and can be applied to any key type and key version stored in Azure Key Vault.
        /// </summary>

        /// <remarks>
        /// In order to perform this operation, the key must already exist in the Key Vault. Note: The cryptographic material of a key itself cannot be changed. This operation requires the keys/update permission.
        /// </remarks>

        /// <param name="key_name">The name of key to update.</param>

        /// <param name="key_version">The version of the key to update.</param>

        /// <param name="parameters">The parameters of the key to update.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The updated key.</returns>

        System.Threading.Tasks.Task<KeyBundle> UpdateKeyAsync(string key_name, string key_version, KeyUpdateParameters parameters, string api_version);

        /// <summary>
        /// Gets the public part of a stored key.
        /// </summary>

        /// <remarks>
        /// The get key operation is applicable to all key types. If the requested key is symmetric, then no key material is released in the response. This operation requires the keys/get permission.
        /// </remarks>

        /// <param name="key_name">The name of the key to get.</param>

        /// <param name="key_version">Adding the version parameter retrieves a specific version of a key. This URI fragment is optional. If not specified, the latest version of the key is returned.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>A key bundle containing the key and its attributes.</returns>

        System.Threading.Tasks.Task<KeyBundle> GetKeyAsync(string key_name, string key_version, string api_version);

        /// <summary>
        /// Retrieves a list of individual key versions with the same key name.
        /// </summary>

        /// <remarks>
        /// The full key identifier, attributes, and tags are provided in the response. This operation requires the keys/list permission.
        /// </remarks>

        /// <param name="key_name">The name of the key.</param>

        /// <param name="maxresults">Maximum number of results to return in a page. If not specified the service will return up to 25 results.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>A response message containing a list of keys along with a link to the next page of keys.</returns>

        System.Threading.Tasks.Task<KeyListResult> GetKeyVersionsAsync(string key_name, int? maxresults, string api_version);

        /// <summary>
        /// List keys in the specified vault.
        /// </summary>

        /// <remarks>
        /// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a stored key. The LIST operation is applicable to all key types, however only the base key identifier, attributes, and tags are provided in the response. Individual versions of a key are not listed in the response. This operation requires the keys/list permission.
        /// </remarks>

        /// <param name="maxresults">Maximum number of results to return in a page. If not specified the service will return up to 25 results.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>A response message containing a list of keys in the vault along with a link to the next page of keys.</returns>

        System.Threading.Tasks.Task<KeyListResult> GetKeysAsync(int? maxresults, string api_version);

        /// <summary>
        /// Requests that a backup of the specified key be downloaded to the client.
        /// </summary>

        /// <remarks>
        /// The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this operation does NOT return key material in a form that can be used outside the Azure Key Vault system, the returned key material is either protected to a Azure Key Vault HSM or to Azure Key Vault itself. The intent of this operation is to allow a client to GENERATE a key in one Azure Key Vault instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance. The BACKUP operation may be used to export, in protected form, any key type from Azure Key Vault. Individual versions of a key cannot be backed up. BACKUP / RESTORE can be performed within geographical boundaries only; meaning that a BACKUP from one geographical area cannot be restored to another geographical area. For example, a backup from the US geographical area cannot be restored in an EU geographical area. This operation requires the key/backup permission.
        /// </remarks>

        /// <param name="key_name">The name of the key.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The backup blob containing the backed up key.</returns>

        System.Threading.Tasks.Task<BackupKeyResult> BackupKeyAsync(string key_name, string api_version);

        /// <summary>
        /// Restores a backed up key to a vault.
        /// </summary>

        /// <remarks>
        /// Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier, attributes and access control policies. The RESTORE operation may be used to import a previously backed up key. Individual versions of a key cannot be restored. The key is restored in its entirety with the same key name as it had when it was backed up. If the key name is not available in the target Key Vault, the RESTORE operation will be rejected. While the key name is retained during restore, the final key identifier will change if the key is restored to a different vault. Restore will restore all versions and preserve version identifiers. The RESTORE operation is subject to security constraints: The target Key Vault must be owned by the same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission in the target Key Vault. This operation requires the keys/restore permission.
        /// </remarks>

        /// <param name="parameters">The parameters to restore the key.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>Restored key bundle in the vault.</returns>

        System.Threading.Tasks.Task<KeyBundle> RestoreKeyAsync(KeyRestoreParameters parameters, string api_version);

        /// <summary>
        /// Encrypts an arbitrary sequence of bytes using an encryption key that is stored in a key vault.
        /// </summary>

        /// <remarks>
        /// The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is stored in Azure Key Vault. Note that the ENCRYPT operation only supports a single block of data, the size of which is dependent on the target key and the encryption algorithm to be used. The ENCRYPT operation is only strictly necessary for symmetric keys stored in Azure Key Vault since protection with an asymmetric key can be performed using public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material. This operation requires the keys/encrypt permission.
        /// </remarks>

        /// <param name="key_name">The name of the key.</param>

        /// <param name="key_version">The version of the key.</param>

        /// <param name="parameters">The parameters for the encryption operation.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The encryption result.</returns>

        System.Threading.Tasks.Task<KeyOperationResult> EncryptAsync(string key_name, string key_version, KeyOperationsParameters parameters, string api_version);

        /// <summary>
        /// Decrypts a single block of encrypted data.
        /// </summary>

        /// <remarks>
        /// The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is the reverse of the ENCRYPT operation; only a single block of data may be decrypted, the size of this block is dependent on the target key and the algorithm to be used. The DECRYPT operation applies to asymmetric and symmetric keys stored in Azure Key Vault since it uses the private portion of the key. This operation requires the keys/decrypt permission. Microsoft recommends not to use CBC algorithms for decryption without first ensuring the integrity of the ciphertext using an HMAC, for example. See https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more information.
        /// </remarks>

        /// <param name="key_name">The name of the key.</param>

        /// <param name="key_version">The version of the key.</param>

        /// <param name="parameters">The parameters for the decryption operation.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The decryption result.</returns>

        System.Threading.Tasks.Task<KeyOperationResult> DecryptAsync(string key_name, string key_version, KeyOperationsParameters parameters, string api_version);

        /// <summary>
        /// Creates a signature from a digest using the specified key.
        /// </summary>

        /// <remarks>
        /// The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault since this operation uses the private portion of the key. This operation requires the keys/sign permission.
        /// </remarks>

        /// <param name="key_name">The name of the key.</param>

        /// <param name="key_version">The version of the key.</param>

        /// <param name="parameters">The parameters for the signing operation.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The signature value.</returns>

        System.Threading.Tasks.Task<KeyOperationResult> SignAsync(string key_name, string key_version, KeySignParameters parameters, string api_version);

        /// <summary>
        /// Verifies a signature using a specified key.
        /// </summary>

        /// <remarks>
        /// The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not strictly necessary for asymmetric keys stored in Azure Key Vault since signature verification can be performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key. This operation requires the keys/verify permission.
        /// </remarks>

        /// <param name="key_name">The name of the key.</param>

        /// <param name="key_version">The version of the key.</param>

        /// <param name="parameters">The parameters for verify operations.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The verification result.</returns>

        System.Threading.Tasks.Task<KeyVerifyResult> VerifyAsync(string key_name, string key_version, KeyVerifyParameters parameters, string api_version);

        /// <summary>
        /// Wraps a symmetric key using a specified key.
        /// </summary>

        /// <remarks>
        /// The WRAP operation supports encryption of a symmetric key using a key encryption key that has previously been stored in an Azure Key Vault. The WRAP operation is only strictly necessary for symmetric keys stored in Azure Key Vault since protection with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material. This operation requires the keys/wrapKey permission.
        /// </remarks>

        /// <param name="key_name">The name of the key.</param>

        /// <param name="key_version">The version of the key.</param>

        /// <param name="parameters">The parameters for wrap operation.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The wrapped symmetric key.</returns>

        System.Threading.Tasks.Task<KeyOperationResult> WrapKeyAsync(string key_name, string key_version, KeyOperationsParameters parameters, string api_version);

        /// <summary>
        /// Unwraps a symmetric key using the specified key that was initially used for wrapping that key.
        /// </summary>

        /// <remarks>
        /// The UNWRAP operation supports decryption of a symmetric key using the target key encryption key. This operation is the reverse of the WRAP operation. The UNWRAP operation applies to asymmetric and symmetric keys stored in Azure Key Vault since it uses the private portion of the key. This operation requires the keys/unwrapKey permission.
        /// </remarks>

        /// <param name="key_name">The name of the key.</param>

        /// <param name="key_version">The version of the key.</param>

        /// <param name="parameters">The parameters for the key operation.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The unwrapped symmetric key.</returns>

        System.Threading.Tasks.Task<KeyOperationResult> UnwrapKeyAsync(string key_name, string key_version, KeyOperationsParameters parameters, string api_version);

        /// <summary>
        /// Releases a key.
        /// </summary>

        /// <remarks>
        /// The release key operation is applicable to all key types. The target key must be marked exportable. This operation requires the keys/release permission.
        /// </remarks>

        /// <param name="key_name">The name of the key to get.</param>

        /// <param name="key_version">Adding the version parameter retrieves a specific version of a key.</param>

        /// <param name="parameters">The parameters for the key release operation.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>A JWS containing the key, its attributes, the result of the key release, and information about the request.</returns>

        System.Threading.Tasks.Task<KeyReleaseResult> ReleaseAsync(string key_name, string key_version, KeyReleaseParameters parameters, string api_version);

        /// <summary>
        /// Lists the deleted keys in the specified vault.
        /// </summary>

        /// <remarks>
        /// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a deleted key. This operation includes deletion-specific information. The Get Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/list permission.
        /// </remarks>

        /// <param name="maxresults">Maximum number of results to return in a page. If not specified the service will return up to 25 results.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>A response message containing a list of deleted keys in the vault along with a link to the next page of deleted keys.</returns>

        System.Threading.Tasks.Task<DeletedKeyListResult> GetDeletedKeysAsync(int? maxresults, string api_version);

        /// <summary>
        /// Gets the public part of a deleted key.
        /// </summary>

        /// <remarks>
        /// The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/get permission.
        /// </remarks>

        /// <param name="key_name">The name of the key.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>A DeletedKeyBundle consisting of a WebKey plus its Attributes and deletion information.</returns>

        System.Threading.Tasks.Task<DeletedKeyBundle> GetDeletedKeyAsync(string key_name, string api_version);

        /// <summary>
        /// Permanently deletes the specified key.
        /// </summary>

        /// <remarks>
        /// The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/purge permission.
        /// </remarks>

        /// <param name="key_name">The name of the key</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>No content, signaling that the key was permanently purged.</returns>

        System.Threading.Tasks.Task PurgeDeletedKeyAsync(string key_name, string api_version);

        /// <summary>
        /// Recovers the deleted key to its latest version.
        /// </summary>

        /// <remarks>
        /// The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults. It recovers the deleted key back to its latest version under /keys. An attempt to recover an non-deleted key will return an error. Consider this the inverse of the delete operation on soft-delete enabled vaults. This operation requires the keys/recover permission.
        /// </remarks>

        /// <param name="key_name">The name of the deleted key.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>A Key bundle of the original key and its attributes</returns>

        System.Threading.Tasks.Task<KeyBundle> RecoverDeletedKeyAsync(string key_name, string api_version);

        /// <summary>
        /// Lists the policy for a key.
        /// </summary>

        /// <remarks>
        /// The GetKeyRotationPolicy operation returns the specified key policy resources in the specified key vault. This operation requires the keys/get permission.
        /// </remarks>

        /// <param name="key_name">The name of the key in a given key vault.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The key rotation policy.</returns>

        System.Threading.Tasks.Task<KeyRotationPolicy> GetKeyRotationPolicyAsync(string key_name, string api_version);

        /// <summary>
        /// Updates the rotation policy for a key.
        /// </summary>

        /// <remarks>
        /// Set specified members in the key policy. Leave others as undefined. This operation requires the keys/update permission.
        /// </remarks>

        /// <param name="key_name">The name of the key in the given vault.</param>

        /// <param name="keyRotationPolicy">The policy for the key.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The policy for the key.</returns>

        System.Threading.Tasks.Task<KeyRotationPolicy> UpdateKeyRotationPolicyAsync(string key_name, KeyRotationPolicy keyRotationPolicy, string api_version);

        /// <summary>
        /// Get the requested number of bytes containing random values.
        /// </summary>

        /// <remarks>
        /// Get the requested number of bytes containing random values from a managed HSM.
        /// </remarks>

        /// <param name="parameters">The request object to get random bytes.</param>

        /// <param name="api_version">Client API version.</param>

        /// <returns>The bytes encoded as a base64url string.</returns>

        System.Threading.Tasks.Task<RandomBytes> GetRandomBytesAsync(GetRandomBytesRequest parameters, string api_version);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]

    [ApiExplorerSettings(GroupName = "Keys")]
    public partial class Controller : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IController _implementation;

        public Controller(IController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Creates a new key, stores it, then returns key parameters and attributes to the client.
        /// </summary>
        /// <remarks>
        /// The create key operation can be used to create any key type in Azure Key Vault. If the named key already exists, Azure Key Vault creates a new version of the key. It requires the keys/create permission.
        /// </remarks>
        /// <param name="key_name">The name for the new key. The system will generate the version name for the new key. The value you provide may be copied globally for the purpose of running the service. The value provided should not include personally identifiable or sensitive information.</param>
        /// <param name="parameters">The parameters to create a key.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>A key bundle containing the result of the create key request.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("keys/{key_name}/create")]
        public System.Threading.Tasks.Task<KeyBundle> CreateKey(string key_name, [Microsoft.AspNetCore.Mvc.FromBody] KeyCreateParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.CreateKeyAsync(key_name, parameters, api_version);
        }

        /// <summary>
        /// Creates a new key version, stores it, then returns key parameters, attributes and policy to the client.
        /// </summary>
        /// <remarks>
        /// The operation will rotate the key based on the key policy. It requires the keys/rotate permission.
        /// </remarks>
        /// <param name="key_name">The name of key to be rotated. The system will generate a new version in the specified key.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>A key bundle containing the result of the rotate key request.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/rotate")]
        public System.Threading.Tasks.Task<KeyBundle> RotateKey(string key_name, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.RotateKeyAsync(key_name, api_version);
        }

        /// <summary>
        /// Imports an externally created key, stores it, and returns key parameters and attributes to the client.
        /// </summary>
        /// <remarks>
        /// The import key operation may be used to import any key type into an Azure Key Vault. If the named key already exists, Azure Key Vault creates a new version of the key. This operation requires the keys/import permission.
        /// </remarks>
        /// <param name="key_name">Name for the imported key. The value you provide may be copied globally for the purpose of running the service. The value provided should not include personally identifiable or sensitive information.</param>
        /// <param name="parameters">The parameters to import a key.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>Imported key bundle to the vault.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}")]
        public System.Threading.Tasks.Task<KeyBundle> ImportKey(string key_name, [Microsoft.AspNetCore.Mvc.FromBody] KeyImportParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.ImportKeyAsync(key_name, parameters, api_version);
        }

        /// <summary>
        /// Deletes a key of any type from storage in Azure Key Vault.
        /// </summary>
        /// <remarks>
        /// The delete key operation cannot be used to remove individual versions of a key. This operation removes the cryptographic material associated with the key, which means the key is not usable for Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations. This operation requires the keys/delete permission.
        /// </remarks>
        /// <param name="key_name">The name of the key to delete.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The public part of the deleted key and deletion information on when the key will be purged.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}")]
        public System.Threading.Tasks.Task<DeletedKeyBundle> DeleteKey(string key_name, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.DeleteKeyAsync(key_name, api_version);
        }

        /// <summary>
        /// The update key operation changes specified attributes of a stored key and can be applied to any key type and key version stored in Azure Key Vault.
        /// </summary>
        /// <remarks>
        /// In order to perform this operation, the key must already exist in the Key Vault. Note: The cryptographic material of a key itself cannot be changed. This operation requires the keys/update permission.
        /// </remarks>
        /// <param name="key_name">The name of key to update.</param>
        /// <param name="key_version">The version of the key to update.</param>
        /// <param name="parameters">The parameters of the key to update.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The updated key.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/{key-version}")]
        public System.Threading.Tasks.Task<KeyBundle> UpdateKey(string key_name, string key_version, [Microsoft.AspNetCore.Mvc.FromBody] KeyUpdateParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.UpdateKeyAsync(key_name, key_version, parameters, api_version);
        }

        /// <summary>
        /// Gets the public part of a stored key.
        /// </summary>
        /// <remarks>
        /// The get key operation is applicable to all key types. If the requested key is symmetric, then no key material is released in the response. This operation requires the keys/get permission.
        /// </remarks>
        /// <param name="key_name">The name of the key to get.</param>
        /// <param name="key_version">Adding the version parameter retrieves a specific version of a key. This URI fragment is optional. If not specified, the latest version of the key is returned.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>A key bundle containing the key and its attributes.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/{key-version}")]
        public System.Threading.Tasks.Task<KeyBundle> GetKey(string key_name, string key_version, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.GetKeyAsync(key_name, key_version, api_version);
        }

        /// <summary>
        /// Retrieves a list of individual key versions with the same key name.
        /// </summary>
        /// <remarks>
        /// The full key identifier, attributes, and tags are provided in the response. This operation requires the keys/list permission.
        /// </remarks>
        /// <param name="key_name">The name of the key.</param>
        /// <param name="maxresults">Maximum number of results to return in a page. If not specified the service will return up to 25 results.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>A response message containing a list of keys along with a link to the next page of keys.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/versions")]
        public System.Threading.Tasks.Task<KeyListResult> GetKeyVersions(string key_name, [Microsoft.AspNetCore.Mvc.FromQuery] int? maxresults, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.GetKeyVersionsAsync(key_name, maxresults, api_version);
        }

        /// <summary>
        /// List keys in the specified vault.
        /// </summary>
        /// <remarks>
        /// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a stored key. The LIST operation is applicable to all key types, however only the base key identifier, attributes, and tags are provided in the response. Individual versions of a key are not listed in the response. This operation requires the keys/list permission.
        /// </remarks>
        /// <param name="maxresults">Maximum number of results to return in a page. If not specified the service will return up to 25 results.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>A response message containing a list of keys in the vault along with a link to the next page of keys.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("keys")]
        public System.Threading.Tasks.Task<KeyListResult> GetKeys([Microsoft.AspNetCore.Mvc.FromQuery] int? maxresults, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.GetKeysAsync(maxresults, api_version);
        }

        /// <summary>
        /// Requests that a backup of the specified key be downloaded to the client.
        /// </summary>
        /// <remarks>
        /// The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this operation does NOT return key material in a form that can be used outside the Azure Key Vault system, the returned key material is either protected to a Azure Key Vault HSM or to Azure Key Vault itself. The intent of this operation is to allow a client to GENERATE a key in one Azure Key Vault instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance. The BACKUP operation may be used to export, in protected form, any key type from Azure Key Vault. Individual versions of a key cannot be backed up. BACKUP / RESTORE can be performed within geographical boundaries only; meaning that a BACKUP from one geographical area cannot be restored to another geographical area. For example, a backup from the US geographical area cannot be restored in an EU geographical area. This operation requires the key/backup permission.
        /// </remarks>
        /// <param name="key_name">The name of the key.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The backup blob containing the backed up key.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/backup")]
        public System.Threading.Tasks.Task<BackupKeyResult> BackupKey(string key_name, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.BackupKeyAsync(key_name, api_version);
        }

        /// <summary>
        /// Restores a backed up key to a vault.
        /// </summary>
        /// <remarks>
        /// Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier, attributes and access control policies. The RESTORE operation may be used to import a previously backed up key. Individual versions of a key cannot be restored. The key is restored in its entirety with the same key name as it had when it was backed up. If the key name is not available in the target Key Vault, the RESTORE operation will be rejected. While the key name is retained during restore, the final key identifier will change if the key is restored to a different vault. Restore will restore all versions and preserve version identifiers. The RESTORE operation is subject to security constraints: The target Key Vault must be owned by the same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission in the target Key Vault. This operation requires the keys/restore permission.
        /// </remarks>
        /// <param name="parameters">The parameters to restore the key.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>Restored key bundle in the vault.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("keys/restore")]
        public System.Threading.Tasks.Task<KeyBundle> RestoreKey([Microsoft.AspNetCore.Mvc.FromBody] KeyRestoreParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.RestoreKeyAsync(parameters, api_version);
        }

        /// <summary>
        /// Encrypts an arbitrary sequence of bytes using an encryption key that is stored in a key vault.
        /// </summary>
        /// <remarks>
        /// The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is stored in Azure Key Vault. Note that the ENCRYPT operation only supports a single block of data, the size of which is dependent on the target key and the encryption algorithm to be used. The ENCRYPT operation is only strictly necessary for symmetric keys stored in Azure Key Vault since protection with an asymmetric key can be performed using public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material. This operation requires the keys/encrypt permission.
        /// </remarks>
        /// <param name="key_name">The name of the key.</param>
        /// <param name="key_version">The version of the key.</param>
        /// <param name="parameters">The parameters for the encryption operation.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The encryption result.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/{key-version}/encrypt")]
        public System.Threading.Tasks.Task<KeyOperationResult> Encrypt(string key_name, string key_version, [Microsoft.AspNetCore.Mvc.FromBody] KeyOperationsParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.EncryptAsync(key_name, key_version, parameters, api_version);
        }

        /// <summary>
        /// Decrypts a single block of encrypted data.
        /// </summary>
        /// <remarks>
        /// The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is the reverse of the ENCRYPT operation; only a single block of data may be decrypted, the size of this block is dependent on the target key and the algorithm to be used. The DECRYPT operation applies to asymmetric and symmetric keys stored in Azure Key Vault since it uses the private portion of the key. This operation requires the keys/decrypt permission. Microsoft recommends not to use CBC algorithms for decryption without first ensuring the integrity of the ciphertext using an HMAC, for example. See https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more information.
        /// </remarks>
        /// <param name="key_name">The name of the key.</param>
        /// <param name="key_version">The version of the key.</param>
        /// <param name="parameters">The parameters for the decryption operation.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The decryption result.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/{key-version}/decrypt")]
        public System.Threading.Tasks.Task<KeyOperationResult> Decrypt(string key_name, string key_version, [Microsoft.AspNetCore.Mvc.FromBody] KeyOperationsParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.DecryptAsync(key_name, key_version, parameters, api_version);
        }

        /// <summary>
        /// Creates a signature from a digest using the specified key.
        /// </summary>
        /// <remarks>
        /// The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault since this operation uses the private portion of the key. This operation requires the keys/sign permission.
        /// </remarks>
        /// <param name="key_name">The name of the key.</param>
        /// <param name="key_version">The version of the key.</param>
        /// <param name="parameters">The parameters for the signing operation.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The signature value.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/{key-version}/sign")]
        public System.Threading.Tasks.Task<KeyOperationResult> Sign(string key_name, string key_version, [Microsoft.AspNetCore.Mvc.FromBody] KeySignParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.SignAsync(key_name, key_version, parameters, api_version);
        }

        /// <summary>
        /// Verifies a signature using a specified key.
        /// </summary>
        /// <remarks>
        /// The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not strictly necessary for asymmetric keys stored in Azure Key Vault since signature verification can be performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key. This operation requires the keys/verify permission.
        /// </remarks>
        /// <param name="key_name">The name of the key.</param>
        /// <param name="key_version">The version of the key.</param>
        /// <param name="parameters">The parameters for verify operations.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The verification result.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/{key-version}/verify")]
        public System.Threading.Tasks.Task<KeyVerifyResult> Verify(string key_name, string key_version, [Microsoft.AspNetCore.Mvc.FromBody] KeyVerifyParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.VerifyAsync(key_name, key_version, parameters, api_version);
        }

        /// <summary>
        /// Wraps a symmetric key using a specified key.
        /// </summary>
        /// <remarks>
        /// The WRAP operation supports encryption of a symmetric key using a key encryption key that has previously been stored in an Azure Key Vault. The WRAP operation is only strictly necessary for symmetric keys stored in Azure Key Vault since protection with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material. This operation requires the keys/wrapKey permission.
        /// </remarks>
        /// <param name="key_name">The name of the key.</param>
        /// <param name="key_version">The version of the key.</param>
        /// <param name="parameters">The parameters for wrap operation.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The wrapped symmetric key.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/{key-version}/wrapkey")]
        public System.Threading.Tasks.Task<KeyOperationResult> WrapKey(string key_name, string key_version, [Microsoft.AspNetCore.Mvc.FromBody] KeyOperationsParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.WrapKeyAsync(key_name, key_version, parameters, api_version);
        }

        /// <summary>
        /// Unwraps a symmetric key using the specified key that was initially used for wrapping that key.
        /// </summary>
        /// <remarks>
        /// The UNWRAP operation supports decryption of a symmetric key using the target key encryption key. This operation is the reverse of the WRAP operation. The UNWRAP operation applies to asymmetric and symmetric keys stored in Azure Key Vault since it uses the private portion of the key. This operation requires the keys/unwrapKey permission.
        /// </remarks>
        /// <param name="key_name">The name of the key.</param>
        /// <param name="key_version">The version of the key.</param>
        /// <param name="parameters">The parameters for the key operation.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The unwrapped symmetric key.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/{key-version}/unwrapkey")]
        public System.Threading.Tasks.Task<KeyOperationResult> UnwrapKey(string key_name, string key_version, [Microsoft.AspNetCore.Mvc.FromBody] KeyOperationsParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.UnwrapKeyAsync(key_name, key_version, parameters, api_version);
        }

        /// <summary>
        /// Releases a key.
        /// </summary>
        /// <remarks>
        /// The release key operation is applicable to all key types. The target key must be marked exportable. This operation requires the keys/release permission.
        /// </remarks>
        /// <param name="key_name">The name of the key to get.</param>
        /// <param name="key_version">Adding the version parameter retrieves a specific version of a key.</param>
        /// <param name="parameters">The parameters for the key release operation.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>A JWS containing the key, its attributes, the result of the key release, and information about the request.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/{key-version}/release")]
        public System.Threading.Tasks.Task<KeyReleaseResult> Release(string key_name, string key_version, [Microsoft.AspNetCore.Mvc.FromBody] KeyReleaseParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.ReleaseAsync(key_name, key_version, parameters, api_version);
        }

        /// <summary>
        /// Lists the deleted keys in the specified vault.
        /// </summary>
        /// <remarks>
        /// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a deleted key. This operation includes deletion-specific information. The Get Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/list permission.
        /// </remarks>
        /// <param name="maxresults">Maximum number of results to return in a page. If not specified the service will return up to 25 results.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>A response message containing a list of deleted keys in the vault along with a link to the next page of deleted keys.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("deletedkeys")]
        public System.Threading.Tasks.Task<DeletedKeyListResult> GetDeletedKeys([Microsoft.AspNetCore.Mvc.FromQuery] int? maxresults, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.GetDeletedKeysAsync(maxresults, api_version);
        }

        /// <summary>
        /// Gets the public part of a deleted key.
        /// </summary>
        /// <remarks>
        /// The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/get permission.
        /// </remarks>
        /// <param name="key_name">The name of the key.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>A DeletedKeyBundle consisting of a WebKey plus its Attributes and deletion information.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("deletedkeys/{key-name}")]
        public System.Threading.Tasks.Task<DeletedKeyBundle> GetDeletedKey(string key_name, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.GetDeletedKeyAsync(key_name, api_version);
        }

        /// <summary>
        /// Permanently deletes the specified key.
        /// </summary>
        /// <remarks>
        /// The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/purge permission.
        /// </remarks>
        /// <param name="key_name">The name of the key</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>No content, signaling that the key was permanently purged.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("deletedkeys/{key-name}")]
        public System.Threading.Tasks.Task PurgeDeletedKey(string key_name, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.PurgeDeletedKeyAsync(key_name, api_version);
        }

        /// <summary>
        /// Recovers the deleted key to its latest version.
        /// </summary>
        /// <remarks>
        /// The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults. It recovers the deleted key back to its latest version under /keys. An attempt to recover an non-deleted key will return an error. Consider this the inverse of the delete operation on soft-delete enabled vaults. This operation requires the keys/recover permission.
        /// </remarks>
        /// <param name="key_name">The name of the deleted key.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>A Key bundle of the original key and its attributes</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("deletedkeys/{key-name}/recover")]
        public System.Threading.Tasks.Task<KeyBundle> RecoverDeletedKey(string key_name, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.RecoverDeletedKeyAsync(key_name, api_version);
        }

        /// <summary>
        /// Lists the policy for a key.
        /// </summary>
        /// <remarks>
        /// The GetKeyRotationPolicy operation returns the specified key policy resources in the specified key vault. This operation requires the keys/get permission.
        /// </remarks>
        /// <param name="key_name">The name of the key in a given key vault.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The key rotation policy.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/rotationpolicy")]
        public System.Threading.Tasks.Task<KeyRotationPolicy> GetKeyRotationPolicy(string key_name, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.GetKeyRotationPolicyAsync(key_name, api_version);
        }

        /// <summary>
        /// Updates the rotation policy for a key.
        /// </summary>
        /// <remarks>
        /// Set specified members in the key policy. Leave others as undefined. This operation requires the keys/update permission.
        /// </remarks>
        /// <param name="key_name">The name of the key in the given vault.</param>
        /// <param name="keyRotationPolicy">The policy for the key.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The policy for the key.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("keys/{key-name}/rotationpolicy")]
        public System.Threading.Tasks.Task<KeyRotationPolicy> UpdateKeyRotationPolicy(string key_name, [Microsoft.AspNetCore.Mvc.FromBody] KeyRotationPolicy keyRotationPolicy, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.UpdateKeyRotationPolicyAsync(key_name, keyRotationPolicy, api_version);
        }

        /// <summary>
        /// Get the requested number of bytes containing random values.
        /// </summary>
        /// <remarks>
        /// Get the requested number of bytes containing random values from a managed HSM.
        /// </remarks>
        /// <param name="parameters">The request object to get random bytes.</param>
        /// <param name="api_version">Client API version.</param>
        /// <returns>The bytes encoded as a base64url string.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("rng")]
        public System.Threading.Tasks.Task<RandomBytes> GetRandomBytes([Microsoft.AspNetCore.Mvc.FromBody] GetRandomBytesRequest parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version)
        {

            return _implementation.GetRandomBytesAsync(parameters, api_version);
        }

    }

    /// <summary>
    /// The get random bytes request object.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetRandomBytesRequest
    {
        /// <summary>
        /// The requested number of random bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1, 128)]
        public int Count { get; set; }

    }

    /// <summary>
    /// The get random bytes response object containing the bytes.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RandomBytes
    {
        /// <summary>
        /// The bytes encoded as a base64url string.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    /// <summary>
    /// The policy rules under which the key can be exported.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyReleasePolicy
    {
        /// <summary>
        /// Content type and version of key release policy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contentType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContentType { get; set; } = "application/json; charset=utf-8";

        /// <summary>
        /// Defines the mutability state of the policy. Once marked immutable, this flag cannot be reset and the policy cannot be changed under any circumstances.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("immutable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Immutable { get; set; }

        /// <summary>
        /// Blob encoding the policy rules under which the key can be released. Blob must be base64 URL encoded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Data { get; set; }

    }

    /// <summary>
    /// As of http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class JsonWebKey
    {
        /// <summary>
        /// Key identifier.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }

        /// <summary>
        /// JsonWebKey Key Type (kty), as defined in https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public JsonWebKeyKty? Kty { get; set; }

        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Key_ops { get; set; }

        /// <summary>
        /// RSA modulus.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("n", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string N { get; set; }

        /// <summary>
        /// RSA public exponent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("e", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string E { get; set; }

        /// <summary>
        /// RSA private exponent, or the D component of an EC private key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("d", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string D { get; set; }

        /// <summary>
        /// RSA private key parameter.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dp { get; set; }

        /// <summary>
        /// RSA private key parameter.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dq", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dq { get; set; }

        /// <summary>
        /// RSA private key parameter.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("qi", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Qi { get; set; }

        /// <summary>
        /// RSA secret prime.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("p", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string P { get; set; }

        /// <summary>
        /// RSA secret prime, with p &lt; q.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("q", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Q { get; set; }

        /// <summary>
        /// Symmetric key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("k", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string K { get; set; }

        /// <summary>
        /// Protected Key, used with 'Bring Your Own Key'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key_hsm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key_hsm { get; set; }

        /// <summary>
        /// Elliptic curve name. For valid values, see JsonWebKeyCurveName.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("crv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public JsonWebKeyCrv? Crv { get; set; }

        /// <summary>
        /// X component of an EC public key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("x", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string X { get; set; }

        /// <summary>
        /// Y component of an EC public key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("y", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Y { get; set; }

    }

    /// <summary>
    /// The attributes of a key managed by the key vault service.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyAttributes : Attributes
    {
        /// <summary>
        /// softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("recoverableDays", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RecoverableDays { get; set; }

        /// <summary>
        /// Reflects the deletion recovery level currently in effect for keys in the current vault. If it contains 'Purgeable' the key can be permanently deleted by a privileged user; otherwise, only the system can purge the key, at the end of the retention interval.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("recoveryLevel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyAttributesRecoveryLevel? RecoveryLevel { get; set; }

        /// <summary>
        /// Indicates if the private key can be exported. Release policy must be provided when creating the first version of an exportable key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exportable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exportable { get; set; }

        /// <summary>
        /// The underlying HSM Platform.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hsmPlatform", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HsmPlatform { get; set; }

    }

    /// <summary>
    /// A KeyBundle consisting of a WebKey plus its attributes.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyBundle
    {
        /// <summary>
        /// The Json web key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonWebKey Key { get; set; }

        /// <summary>
        /// The key management attributes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyAttributes Attributes { get; set; }

        /// <summary>
        /// Application specific metadata in the form of key-value pairs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Tags { get; set; }

        /// <summary>
        /// True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("managed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Managed { get; set; }

        /// <summary>
        /// The policy rules under which the key can be exported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("release_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyReleasePolicy Release_policy { get; set; }

    }

    /// <summary>
    /// The key item containing key metadata.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyItem
    {
        /// <summary>
        /// Key identifier.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }

        /// <summary>
        /// The key management attributes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyAttributes Attributes { get; set; }

        /// <summary>
        /// Application specific metadata in the form of key-value pairs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Tags { get; set; }

        /// <summary>
        /// True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("managed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Managed { get; set; }

    }

    /// <summary>
    /// A DeletedKeyBundle consisting of a WebKey plus its Attributes and deletion info
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeletedKeyBundle : KeyBundle
    {
        /// <summary>
        /// The url of the recovery object, used to identify and recover the deleted key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("recoveryId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RecoveryId { get; set; }

        /// <summary>
        /// The time when the key is scheduled to be purged, in UTC
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scheduledPurgeDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ScheduledPurgeDate { get; set; }

        /// <summary>
        /// The time when the key was deleted, in UTC
        /// </summary>
        [Newtonsoft.Json.JsonProperty("deletedDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DeletedDate { get; set; }

    }

    /// <summary>
    /// The deleted key item containing the deleted key metadata and information about deletion.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeletedKeyItem : KeyItem
    {
        /// <summary>
        /// The url of the recovery object, used to identify and recover the deleted key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("recoveryId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RecoveryId { get; set; }

        /// <summary>
        /// The time when the key is scheduled to be purged, in UTC
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scheduledPurgeDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ScheduledPurgeDate { get; set; }

        /// <summary>
        /// The time when the key was deleted, in UTC
        /// </summary>
        [Newtonsoft.Json.JsonProperty("deletedDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DeletedDate { get; set; }

    }

    /// <summary>
    /// Properties of the key pair backing a certificate.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyProperties
    {
        /// <summary>
        /// Indicates if the private key can be exported. Release policy must be provided when creating the first version of an exportable key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exportable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exportable { get; set; }

        /// <summary>
        /// The type of key pair to be used for the certificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyPropertiesKty? Kty { get; set; }

        /// <summary>
        /// The key size in bits. For example: 2048, 3072, or 4096 for RSA.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Key_size { get; set; }

        /// <summary>
        /// Indicates if the same key pair will be used on certificate renewal.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reuse_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Reuse_key { get; set; }

        /// <summary>
        /// Elliptic curve name. For valid values, see JsonWebKeyCurveName.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("crv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyPropertiesCrv? Crv { get; set; }

    }

    /// <summary>
    /// The key create parameters.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyCreateParameters
    {
        /// <summary>
        /// The type of key to create. For valid values, see JsonWebKeyType.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kty", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyCreateParametersKty Kty { get; set; }

        /// <summary>
        /// The key size in bits. For example: 2048, 3072, or 4096 for RSA.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Key_size { get; set; }

        /// <summary>
        /// The public exponent for a RSA key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("public_exponent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Public_exponent { get; set; }

        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.List<Key_ops> Key_ops { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyAttributes Attributes { get; set; }

        /// <summary>
        /// Application specific metadata in the form of key-value pairs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Tags { get; set; }

        /// <summary>
        /// Elliptic curve name. For valid values, see JsonWebKeyCurveName.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("crv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyCreateParametersCrv? Crv { get; set; }

        /// <summary>
        /// The policy rules under which the key can be exported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("release_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyReleasePolicy Release_policy { get; set; }

    }

    /// <summary>
    /// The key import parameters.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyImportParameters
    {
        /// <summary>
        /// Whether to import as a hardware key (HSM) or software key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Hsm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Hsm { get; set; }

        /// <summary>
        /// The Json web key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public JsonWebKey Key { get; set; }

        /// <summary>
        /// The key management attributes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyAttributes Attributes { get; set; }

        /// <summary>
        /// Application specific metadata in the form of key-value pairs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Tags { get; set; }

        /// <summary>
        /// The policy rules under which the key can be exported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("release_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyReleasePolicy Release_policy { get; set; }

    }

    /// <summary>
    /// The export key parameters.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyExportParameters
    {
        /// <summary>
        /// The export key encryption Json web key. This key MUST be a RSA key that supports encryption.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wrappingKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JsonWebKey WrappingKey { get; set; }

        /// <summary>
        /// The export key encryption key identifier. This key MUST be a RSA key that supports encryption.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wrappingKid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WrappingKid { get; set; }

        /// <summary>
        /// The encryption algorithm to use to protected the exported key material
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enc", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength = 1)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyExportParametersEnc? Enc { get; set; }

    }

    /// <summary>
    /// The release key parameters.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyReleaseParameters
    {
        /// <summary>
        /// The attestation assertion for the target of the key release.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public string Target { get; set; }

        /// <summary>
        /// A client provided nonce for freshness.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nonce", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nonce { get; set; }

        /// <summary>
        /// The encryption algorithm to use to protected the exported key material
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enc", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength = 1)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyReleaseParametersEnc? Enc { get; set; }

    }

    /// <summary>
    /// The key operations parameters.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyOperationsParameters
    {
        /// <summary>
        /// algorithm identifier
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyOperationsParametersAlg Alg { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

        /// <summary>
        /// Cryptographically random, non-repeating initialization vector for symmetric algorithms.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Iv { get; set; }

        /// <summary>
        /// Additional data to authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Aad { get; set; }

        /// <summary>
        /// The tag to authenticate when performing decryption with an authenticated algorithm.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tag { get; set; }

    }

    /// <summary>
    /// The key operations parameters.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeySignParameters
    {
        /// <summary>
        /// The signing/verification algorithm identifier. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeySignParametersAlg Alg { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    /// <summary>
    /// The key verify parameters.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyVerifyParameters
    {
        /// <summary>
        /// The signing/verification algorithm. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyVerifyParametersAlg Alg { get; set; }

        /// <summary>
        /// The digest used for signing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("digest", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Digest { get; set; }

        /// <summary>
        /// The signature to be verified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    /// <summary>
    /// The key update parameters.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyUpdateParameters
    {
        /// <summary>
        /// Json web key operations. For more information on possible key operations, see JsonWebKeyOperation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.List<key_ops> Key_ops { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyAttributes Attributes { get; set; }

        /// <summary>
        /// Application specific metadata in the form of key-value pairs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Tags { get; set; }

        /// <summary>
        /// The policy rules under which the key can be exported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("release_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyReleasePolicy Release_policy { get; set; }

    }

    /// <summary>
    /// The key restore parameters.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyRestoreParameters
    {
        /// <summary>
        /// The backup blob associated with a key bundle.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    /// <summary>
    /// The key operation result.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyOperationResult
    {
        /// <summary>
        /// Key identifier
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Iv { get; set; }

        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tag { get; set; }

        [Newtonsoft.Json.JsonProperty("aad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Aad { get; set; }

    }

    /// <summary>
    /// The key verify result.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyVerifyResult
    {
        /// <summary>
        /// True if the signature is verified, otherwise false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Value { get; set; }

    }

    /// <summary>
    /// The key list result.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyListResult
    {
        /// <summary>
        /// A response message containing a list of keys in the key vault along with a link to the next page of keys.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<KeyItem> Value { get; set; }

        /// <summary>
        /// The URL to get the next set of keys.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextLink { get; set; }

    }

    /// <summary>
    /// A list of keys that have been deleted in this vault.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeletedKeyListResult
    {
        /// <summary>
        /// A response message containing a list of deleted keys in the vault along with a link to the next page of deleted keys
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<DeletedKeyItem> Value { get; set; }

        /// <summary>
        /// The URL to get the next set of deleted keys.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextLink { get; set; }

    }

    /// <summary>
    /// The backup key result, containing the backup blob.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BackupKeyResult
    {
        /// <summary>
        /// The backup blob containing the backed up key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    /// <summary>
    /// Management policy for a key.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyRotationPolicy
    {
        /// <summary>
        /// The key policy id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Actions that will be performed by Key Vault over the lifetime of a key. For preview, lifetimeActions can only have two items at maximum: one for rotate, one for notify. Notification time would be default to 30 days before expiry and it is not configurable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lifetimeActions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<LifetimeActions> LifetimeActions { get; set; }

        /// <summary>
        /// The key rotation policy attributes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyRotationPolicyAttributes Attributes { get; set; }

    }

    /// <summary>
    /// Action and its trigger that will be performed by Key Vault over the lifetime of a key.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LifetimeActions
    {
        /// <summary>
        /// The condition that will execute the action.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trigger", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LifetimeActionsTrigger Trigger { get; set; }

        /// <summary>
        /// The action that will be executed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LifetimeActionsType Action { get; set; }

    }

    /// <summary>
    /// A condition to be satisfied for an action to be executed.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LifetimeActionsTrigger
    {
        /// <summary>
        /// Time after creation to attempt to rotate. It only applies to rotate. It will be in ISO 8601 duration format. Example: 90 days : "P90D"  
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeAfterCreate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TimeAfterCreate { get; set; }

        /// <summary>
        /// Time before expiry to attempt to rotate or notify. It will be in ISO 8601 duration format. Example: 90 days : "P90D"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeBeforeExpiry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TimeBeforeExpiry { get; set; }

    }

    /// <summary>
    /// The action that will be executed.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LifetimeActionsType
    {
        /// <summary>
        /// The type of the action. The value should be compared case-insensitively.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LifetimeActionsTypeType? Type { get; set; }

    }

    /// <summary>
    /// The key rotation policy attributes.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyRotationPolicyAttributes
    {
        /// <summary>
        /// The expiryTime will be applied on the new key version. It should be at least 28 days. It will be in ISO 8601 Format. Examples: 90 days: P90D, 3 months: P3M, 48 hours: PT48H, 1 year and 10 days: P1Y10D
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiryTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExpiryTime { get; set; }

        /// <summary>
        /// The key rotation policy created time in UTC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Created { get; set; }

        /// <summary>
        /// The key rotation policy's last updated time in UTC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("updated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Updated { get; set; }

    }

    /// <summary>
    /// The release result, containing the released key.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyReleaseResult
    {
        /// <summary>
        /// A signed object containing the released key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    /// <summary>
    /// The key vault error exception.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyVaultError
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Error Error { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The object attributes managed by the KeyVault service.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Attributes
    {
        /// <summary>
        /// Determines whether the object is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }

        /// <summary>
        /// Not before date in UTC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nbf", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Nbf { get; set; }

        /// <summary>
        /// Expiry date in UTC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Exp { get; set; }

        /// <summary>
        /// Creation time in UTC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Created { get; set; }

        /// <summary>
        /// Last updated time in UTC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("updated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Updated { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum JsonWebKeyKty
    {

        [System.Runtime.Serialization.EnumMember(Value = @"EC")]
        EC = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"EC-HSM")]
        ECHSM = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA")]
        RSA = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA-HSM")]
        RSAHSM = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"oct")]
        Oct = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"oct-HSM")]
        OctHSM = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum JsonWebKeyCrv
    {

        [System.Runtime.Serialization.EnumMember(Value = @"P-256")]
        P256 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"P-384")]
        P384 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"P-521")]
        P521 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"P-256K")]
        P256K = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KeyAttributesRecoveryLevel
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Purgeable")]
        Purgeable = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Recoverable+Purgeable")]
        Recoverable_Purgeable = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Recoverable")]
        Recoverable = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Recoverable+ProtectedSubscription")]
        Recoverable_ProtectedSubscription = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"CustomizedRecoverable+Purgeable")]
        CustomizedRecoverable_Purgeable = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"CustomizedRecoverable")]
        CustomizedRecoverable = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"CustomizedRecoverable+ProtectedSubscription")]
        CustomizedRecoverable_ProtectedSubscription = 6,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KeyPropertiesKty
    {

        [System.Runtime.Serialization.EnumMember(Value = @"EC")]
        EC = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"EC-HSM")]
        ECHSM = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA")]
        RSA = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA-HSM")]
        RSAHSM = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"oct")]
        Oct = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"oct-HSM")]
        OctHSM = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KeyPropertiesCrv
    {

        [System.Runtime.Serialization.EnumMember(Value = @"P-256")]
        P256 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"P-384")]
        P384 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"P-521")]
        P521 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"P-256K")]
        P256K = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KeyCreateParametersKty
    {

        [System.Runtime.Serialization.EnumMember(Value = @"EC")]
        EC = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"EC-HSM")]
        ECHSM = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA")]
        RSA = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA-HSM")]
        RSAHSM = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"oct")]
        Oct = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"oct-HSM")]
        OctHSM = 5,

    }

    /// <summary>
    /// JSON web key operations. For more information, see JsonWebKeyOperation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Key_ops
    {

        [System.Runtime.Serialization.EnumMember(Value = @"encrypt")]
        Encrypt = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"decrypt")]
        Decrypt = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"sign")]
        Sign = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"verify")]
        Verify = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"wrapKey")]
        WrapKey = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"unwrapKey")]
        UnwrapKey = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"import")]
        Import = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"export")]
        Export = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KeyCreateParametersCrv
    {

        [System.Runtime.Serialization.EnumMember(Value = @"P-256")]
        P256 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"P-384")]
        P384 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"P-521")]
        P521 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"P-256K")]
        P256K = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KeyExportParametersEnc
    {

        [System.Runtime.Serialization.EnumMember(Value = @"CKM_RSA_AES_KEY_WRAP")]
        CKM_RSA_AES_KEY_WRAP = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA_AES_KEY_WRAP_256")]
        RSA_AES_KEY_WRAP_256 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA_AES_KEY_WRAP_384")]
        RSA_AES_KEY_WRAP_384 = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KeyReleaseParametersEnc
    {

        [System.Runtime.Serialization.EnumMember(Value = @"CKM_RSA_AES_KEY_WRAP")]
        CKM_RSA_AES_KEY_WRAP = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA_AES_KEY_WRAP_256")]
        RSA_AES_KEY_WRAP_256 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA_AES_KEY_WRAP_384")]
        RSA_AES_KEY_WRAP_384 = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KeyOperationsParametersAlg
    {

        [System.Runtime.Serialization.EnumMember(Value = @"RSA-OAEP")]
        RSAOAEP = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA-OAEP-256")]
        RSAOAEP256 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RSA1_5")]
        RSA1_5 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"A128GCM")]
        A128GCM = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"A192GCM")]
        A192GCM = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"A256GCM")]
        A256GCM = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"A128KW")]
        A128KW = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"A192KW")]
        A192KW = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"A256KW")]
        A256KW = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"A128CBC")]
        A128CBC = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"A192CBC")]
        A192CBC = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"A256CBC")]
        A256CBC = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"A128CBCPAD")]
        A128CBCPAD = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"A192CBCPAD")]
        A192CBCPAD = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"A256CBCPAD")]
        A256CBCPAD = 14,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KeySignParametersAlg
    {

        [System.Runtime.Serialization.EnumMember(Value = @"PS256")]
        PS256 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PS384")]
        PS384 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"PS512")]
        PS512 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"RS256")]
        RS256 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"RS384")]
        RS384 = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RS512")]
        RS512 = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"RSNULL")]
        RSNULL = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"ES256")]
        ES256 = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"ES384")]
        ES384 = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"ES512")]
        ES512 = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"ES256K")]
        ES256K = 10,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KeyVerifyParametersAlg
    {

        [System.Runtime.Serialization.EnumMember(Value = @"PS256")]
        PS256 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PS384")]
        PS384 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"PS512")]
        PS512 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"RS256")]
        RS256 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"RS384")]
        RS384 = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RS512")]
        RS512 = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"RSNULL")]
        RSNULL = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"ES256")]
        ES256 = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"ES384")]
        ES384 = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"ES512")]
        ES512 = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"ES256K")]
        ES256K = 10,

    }

    /// <summary>
    /// JSON web key operations. For more information, see JsonWebKeyOperation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum key_ops
    {

        [System.Runtime.Serialization.EnumMember(Value = @"encrypt")]
        Encrypt = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"decrypt")]
        Decrypt = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"sign")]
        Sign = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"verify")]
        Verify = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"wrapKey")]
        WrapKey = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"unwrapKey")]
        UnwrapKey = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"import")]
        Import = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"export")]
        Export = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum LifetimeActionsTypeType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Rotate")]
        Rotate = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Notify")]
        Notify = 1,

    }

    /// <summary>
    /// The key vault server error.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Error
    {
        /// <summary>
        /// The error code.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }

        /// <summary>
        /// The error message.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("innererror", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Error Innererror { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }


}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625